/**
 * Memory Storage Utility
 * 
 * Handles storage of user-contributed memories via the "remember this" command.
 * Integrates with @elizaos/plugin-knowledge to persist memories alongside wiki and telegram archives.
 * 
 * IMPORTANT: KnowledgeService strips custom metadata, so we embed memory metadata directly in the
 * content using the format: [MEMORY:userId:displayName:timestamp] actual_content
 * This marker is parsed during retrieval (loreRetrieval.ts) and stripped from display text.
 */

import type { IAgentRuntime, Memory } from '@elizaos/core';
import type { MemoryContent, MemoryStorageResult, UserMemoryMetadata } from '../types/memory';
import { FULL_CARD_INDEX } from '../data/fullCardIndex';

/**
 * Store a user-contributed memory in the knowledge database
 */
export async function storeUserMemory(
  runtime: IAgentRuntime,
  message: Memory,
  rawMessage?: any
): Promise<MemoryStorageResult> {
  try {
    const messageText = message.content.text || '';
    const isReply = !!message.content.inReplyTo && !!rawMessage?.reply_to_message;
    const originalMessage = rawMessage?.reply_to_message?.text || '';
    
    // Extract content
    const content = extractMemoryContent(messageText, isReply, originalMessage);
    
    // Validate content
    const validation = validateMemoryContent(content);
    if (!validation.valid) {
      console.debug(`[memoryStorage] Ignoring: ${validation.reason}`);
      return {
        success: true,  // Success = no error, just ignored
        ignoredReason: validation.reason
      };
    }
    
    // Build metadata
    const metadata = buildMemoryMetadata(runtime, message, rawMessage, content);
    
    // Detect card name for card-specific memories
    const cardName = detectCardForMemory(content.text);
    const memoryType = cardName ? 'CARD memory' : 'Static memory';
    
    console.log(`[memoryStorage] Storing ${memoryType} for ${metadata.displayName}${cardName ? ` (card: ${cardName})` : ''}`);
    
    // Get KnowledgeService
    const knowledgeService = (runtime as any).getService
      ? (runtime as any).getService('knowledge')
      : null;
    
    if (!knowledgeService) {
      console.error('[memoryStorage] KnowledgeService not available');
      return {
        success: false,
        error: 'Knowledge service unavailable'
      };
    }
    
    // Store in knowledge database with embedded metadata marker
    // Card memories get [CARD:NAME] marker for exact matching during retrieval
    const contentWithMetadata = cardName
      ? `[MEMORY:${metadata.userId}:${metadata.displayName}:${metadata.timestamp}][CARD:${cardName}] ${content.text}`
      : `[MEMORY:${metadata.userId}:${metadata.displayName}:${metadata.timestamp}] ${content.text}`;
    
    const result = await knowledgeService.addKnowledge({
      agentId: runtime.agentId,
      clientDocumentId: '' as any, // Auto-generated by service
      content: contentWithMetadata,
      contentType: 'text/plain',
      originalFilename: `memory-${metadata.userId}-${metadata.timestamp}`,
      worldId: runtime.agentId,
      roomId: runtime.agentId,
      entityId: runtime.agentId,
      metadata: metadata // Will be stripped by service, but passed for completeness
    });
    
    if (result && result.success !== false) {
      console.log(`[memoryStorage] ${memoryType} stored successfully${cardName ? ` for ${cardName}` : ''}`);
      return {
        success: true,
        memoryId: result.documentId || 'unknown'
      };
    } else {
      console.error('[memoryStorage] Storage failed:', result?.error);
      return {
        success: false,
        error: result?.error || 'Storage failed'
      };
    }
  } catch (error) {
    console.error('[memoryStorage] Exception during storage:', error);
    return {
      success: false,
      error: error instanceof Error ? error.message : 'Unknown error'
    };
  }
}

/**
 * Extract content to be remembered from the message
 */
export function extractMemoryContent(
  messageText: string,
  isReply: boolean,
  originalMessage?: string
): MemoryContent {
  // Remove "remember this" trigger phrase and extract content
  const cleanText = messageText.replace(/remember\s+this[:\s]*/i, '').trim();
  
  if (isReply && originalMessage) {
    // REPLY flow: combine original bot message + user's comment
    const userComment = cleanText || messageText.trim();
    const combinedText = `${originalMessage}\n\nUser comment: ${userComment}`;
    
    return {
      text: combinedText,
      isReplyContext: true,
      originalMessage: originalMessage,
      userComment: userComment
    };
  } else {
    // Direct command: just use the text after "remember this"
    return {
      text: cleanText,
      isReplyContext: false,
      userComment: cleanText
    };
  }
}

/**
 * Validate memory content before storage
 */
export function validateMemoryContent(content: MemoryContent): {
  valid: boolean;
  reason?: 'empty_content' | 'too_long' | 'invalid_format';
} {
  // Check for empty or whitespace-only content (FR-014)
  if (!content.text || content.text.trim().length === 0) {
    return {
      valid: false,
      reason: 'empty_content'
    };
  }
  
  // Check for excessively long content (reasonable limit: 10k chars)
  if (content.text.length > 10000) {
    return {
      valid: false,
      reason: 'too_long'
    };
  }
  
  return {
    valid: true
  };
}

/**
 * Build metadata object for knowledge storage
 */
/**
 * Detect card name in first sentence for card-specific memories
 */
export function detectCardForMemory(text: string): string | null {
  const firstSentence = text.split(/[.!?]/)[0];
  const capitalWords = firstSentence.match(/\b[A-Z]{3,}[A-Z0-9]*\b/g) || [];
  
  for (const word of capitalWords) {
    const isValidCard = FULL_CARD_INDEX.some(card => 
      card.asset.toUpperCase() === word.toUpperCase()
    );
    
    if (isValidCard) {
      return word.toUpperCase();
    }
  }
  
  return null;
}

export function buildMemoryMetadata(
  runtime: IAgentRuntime,
  message: Memory,
  rawMessage: any,
  content: MemoryContent
): UserMemoryMetadata {
  // Extract user information from Telegram message
  const userId = rawMessage?.from?.id?.toString() || (message as any).userId || 'unknown';
  const displayName = rawMessage?.from?.first_name || 
                     rawMessage?.from?.username || 
                     (message as any).userName ||
                     'Unknown';
  const roomId = rawMessage?.chat?.id?.toString() || message.roomId || 'unknown';
  const messageId = rawMessage?.message_id?.toString() || (message as any).id?.toString() || 'unknown';
  
  const metadata: UserMemoryMetadata = {
    sourceType: 'memory',
    userId,
    displayName,
    roomId,
    messageId,
    timestamp: Date.now()
  };
  
  // Add original context if this is a REPLY flow
  if (content.isReplyContext && content.originalMessage) {
    metadata.originalContext = content.originalMessage;
  }
  
  return metadata;
}

