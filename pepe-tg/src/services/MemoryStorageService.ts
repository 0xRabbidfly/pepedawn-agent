/**
 * Memory Storage Service
 * 
 * ElizaOS Service implementation for user-contributed memory storage.
 * Handles "remember this" command with card detection and metadata embedding.
 * 
 * Migrated from functional module to Service pattern for:
 * - Lifecycle management (init/stop)
 * - Discoverability via runtime.getService()
 * - Better composability with KnowledgeOrchestratorService
 * - Performance optimization (cached card index)
 */

import { Service, type IAgentRuntime, type Memory } from '@elizaos/core';
import type { MemoryContent, MemoryStorageResult, UserMemoryMetadata } from '../types/memory';
import { FULL_CARD_INDEX } from '../data/fullCardIndex';

export class MemoryStorageService extends Service {
  static serviceType = 'memory-storage';
  
  capabilityDescription = 
    'Manages user-contributed memory storage with card detection, metadata embedding, ' +
    'and knowledge service integration for "remember this" commands.';

  // Cached card index for O(1) lookups
  private cardIndex: Set<string>;

  constructor(runtime: IAgentRuntime) {
    super(runtime);
    // Pre-build card index for fast lookups
    this.cardIndex = new Set(FULL_CARD_INDEX.map(c => c.asset.toUpperCase()));
  }

  /**
   * Initialize service
   */
  static async start(runtime: IAgentRuntime): Promise<MemoryStorageService> {
    logger.info('ðŸ’¾ [MemoryStorage] Starting service...');
    const service = new MemoryStorageService(runtime);
    logger.info(`ðŸ’¾ [MemoryStorage] Card index cached (${service.cardIndex.size} cards)`);
    logger.info('âœ… [MemoryStorage] Service ready');
    return service;
  }

  /**
   * Cleanup service
   */
  static async stop(runtime: IAgentRuntime): Promise<void> {
    logger.info('ðŸ›‘ [MemoryStorage] Stopping service...');
    const service = runtime.getService(MemoryStorageService.serviceType);
    if (service) {
      await service.stop();
    }
  }

  async stop(): Promise<void> {
    logger.info('âœ… [MemoryStorage] Service stopped');
  }

  /**
   * Store user-contributed memory in knowledge database
   * 
   * @param message - ElizaOS Memory object from user
   * @param rawMessage - Optional raw Telegram message for metadata extraction
   * @returns Storage result with success/error/ignored status
   */
  async storeMemory(
    message: Memory,
    rawMessage?: any
  ): Promise<MemoryStorageResult> {
    try {
      const messageText = message.content.text || '';
      const isReply = !!message.content.inReplyTo && !!rawMessage?.reply_to_message;
      const originalMessage = rawMessage?.reply_to_message?.text || '';
      
      // Extract content
      const content = this.extractMemoryContent(messageText, isReply, originalMessage);
      
      // Validate content
      const validation = this.validateMemoryContent(content);
      if (!validation.valid) {
        logger.debug(`[MemoryStorage] Ignoring: ${validation.reason}`);
        return {
          success: true,  // Success = no error, just ignored
          ignoredReason: validation.reason
        };
      }
      
      // Build metadata
      const metadata = this.buildMemoryMetadata(message, rawMessage, content);
      
      // Detect card name for card-specific memories (uses cached index)
      const cardName = this.detectCard(content.text);
      const memoryType = cardName ? 'CARD memory' : 'Static memory';
      
      logger.info(`[MemoryStorage] Storing ${memoryType} for ${metadata.displayName}${cardName ? ` (card: ${cardName})` : ''}`);
      
      // Get KnowledgeService
      const knowledgeService = (this.runtime as any).getService
        ? (this.runtime as any).getService('knowledge')
        : null;
      
      if (!knowledgeService) {
        logger.error('[MemoryStorage] KnowledgeService not available');
        return {
          success: false,
          error: 'Knowledge service unavailable'
        };
      }
      
      // Store in knowledge database with embedded metadata marker
      // Card memories get [CARD:NAME] marker for exact matching during retrieval
      const contentWithMetadata = cardName
        ? `[MEMORY:${metadata.userId}:${metadata.displayName}:${metadata.timestamp}][CARD:${cardName}] ${content.text}`
        : `[MEMORY:${metadata.userId}:${metadata.displayName}:${metadata.timestamp}] ${content.text}`;
      
      const result = await knowledgeService.addKnowledge({
        agentId: this.runtime.agentId,
        clientDocumentId: '' as any, // Auto-generated by service
        content: contentWithMetadata,
        contentType: 'text/plain',
        originalFilename: `memory-${metadata.userId}-${metadata.timestamp}`,
        worldId: this.runtime.agentId,
        roomId: this.runtime.agentId,
        entityId: this.runtime.agentId,
        metadata: metadata // Will be stripped by service, but passed for completeness
      });
      
      if (result && result.success !== false) {
        logger.info(`[MemoryStorage] ${memoryType} stored successfully${cardName ? ` for ${cardName}` : ''}`);
        return {
          success: true,
          memoryId: result.documentId || 'unknown'
        };
      } else {
        logger.error('[MemoryStorage] Storage failed:', result?.error);
        return {
          success: false,
          error: result?.error || 'Storage failed'
        };
      }
    } catch (error) {
      logger.error('[MemoryStorage] Exception during storage:', error);
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Unknown error'
      };
    }
  }

  /**
   * Extract content to be remembered from the message
   */
  private extractMemoryContent(
    messageText: string,
    isReply: boolean,
    originalMessage?: string
  ): MemoryContent {
    // Remove "remember" or "remember this" trigger phrase and extract content
    const cleanText = messageText.replace(/remember(?:\s+this)?[:\s]*/i, '').trim();
    
    if (isReply && originalMessage) {
      // REPLY flow: combine original bot message + user's comment
      const userComment = cleanText || messageText.trim();
      const combinedText = `${originalMessage}\n\nUser comment: ${userComment}`;
      
      return {
        text: combinedText,
        isReplyContext: true,
        originalMessage: originalMessage,
        userComment: userComment
      };
    } else {
      // Direct command: just use the text after "remember this"
      return {
        text: cleanText,
        isReplyContext: false,
        userComment: cleanText
      };
    }
  }

  /**
   * Validate memory content before storage
   */
  private validateMemoryContent(content: MemoryContent): {
    valid: boolean;
    reason?: 'empty_content' | 'too_long' | 'invalid_format';
  } {
    // Check for empty or whitespace-only content
    if (!content.text || content.text.trim().length === 0) {
      return {
        valid: false,
        reason: 'empty_content'
      };
    }
    
    // Check for excessively long content (reasonable limit: 10k chars)
    if (content.text.length > 10000) {
      return {
        valid: false,
        reason: 'too_long'
      };
    }
    
    return {
      valid: true
    };
  }

  /**
   * Detect card name in first sentence (uses cached card index for O(1) lookup)
   */
  private detectCard(text: string): string | null {
    const firstSentence = text.split(/[.!?]/)[0];
    const capitalWords = firstSentence.match(/\b[A-Z]{3,}[A-Z0-9]*\b/g) || [];
    
    for (const word of capitalWords) {
      if (this.cardIndex.has(word.toUpperCase())) {
        return word.toUpperCase();
      }
    }
    
    return null;
  }

  /**
   * Build metadata object for knowledge storage
   */
  private buildMemoryMetadata(
    message: Memory,
    rawMessage: any,
    content: MemoryContent
  ): UserMemoryMetadata {
    // Extract user information from Telegram message
    const userId = rawMessage?.from?.id?.toString() || (message as any).userId || 'unknown';
    const displayName = rawMessage?.from?.first_name || 
                       rawMessage?.from?.username || 
                       (message as any).userName ||
                       'Unknown';
    const roomId = rawMessage?.chat?.id?.toString() || message.roomId || 'unknown';
    const messageId = rawMessage?.message_id?.toString() || (message as any).id?.toString() || 'unknown';
    
    const metadata: UserMemoryMetadata = {
      sourceType: 'memory',
      userId,
      displayName,
      roomId,
      messageId,
      timestamp: Date.now()
    };
    
    // Add original context if this is a REPLY flow
    if (content.isReplyContext && content.originalMessage) {
      metadata.originalContext = content.originalMessage;
    }
    
    return metadata;
  }
}

