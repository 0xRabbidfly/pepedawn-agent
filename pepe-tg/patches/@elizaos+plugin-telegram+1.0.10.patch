diff --git a/node_modules/@elizaos/plugin-telegram/dist/index.js b/node_modules/@elizaos/plugin-telegram/dist/index.js
index 6a508dd..eab5b37 100644
--- a/node_modules/@elizaos/plugin-telegram/dist/index.js
+++ b/node_modules/@elizaos/plugin-telegram/dist/index.js
@@ -19,7 +19,7 @@ import {
   Role,
   Service,
   createUniqueUuid as createUniqueUuid2,
-  logger as logger2
+  logger as logger3
 } from "@elizaos/core";
 import { Telegraf } from "telegraf";
 
@@ -28,13 +28,15 @@ import {
   ChannelType,
   EventType,
   ModelType,
+  ServiceType,
   createUniqueUuid,
-  logger
+  logger as logger2
 } from "@elizaos/core";
 import { Markup as Markup2 } from "telegraf";
 
 // src/utils.ts
 import { Markup } from "telegraf";
+import { logger } from "@elizaos/core";
 var TELEGRAM_RESERVED_REGEX = /([_*[\]()~`>#+\-=|{}.!\\])/g;
 function escapePlainText(text) {
   if (!text) return "";
@@ -56,7 +58,62 @@ function escapeCode(text) {
 }
 function escapeUrl(url) {
   if (!url) return "";
-  return url.replace(/([)\\])/g, "\\$1");
+  // FIX: also escape underscores for MarkdownV2
+  return url.replace(/([)\\_])/g, "\\$1");
+}
+function encodeUrlForTelegram(url) {
+  try {
+    const urlObj = new URL(url);
+    const encodedUrl = urlObj.toString();
+    return encodedUrl;
+  } catch (error) {
+    return url;
+  }
+}
+function isProblematicVideoUrl(url) {
+  try {
+    const urlObj = new URL(url);
+    const problematicPatterns = [
+      // Arweave URLs (known to have issues)
+      /arweave\.net/i,
+      // URLs with underscores in filenames
+      /_[^\/]*\.(mp4|avi|mov|mkv|webm)$/i,
+      // URLs with special characters in path
+      /[^a-zA-Z0-9\/\-\._~!$&'()*+,;=:@%]/
+    ];
+    const hasProblematicPattern = problematicPatterns.some((pattern) => pattern.test(url));
+    const hasLongPath = urlObj.pathname.length > 100;
+    const hasComplexQuery = urlObj.search.length > 50;
+    return hasProblematicPattern || hasLongPath || hasComplexQuery;
+  } catch (error) {
+    return true;
+  }
+}
+function generateAlternativeUrls(url) {
+  const alternatives = [];
+  try {
+    const urlObj = new URL(url);
+    if (urlObj.hostname === "arweave.net") {
+      const pathParts = urlObj.pathname.split("/");
+      if (pathParts.length >= 3) {
+        const filename = pathParts[pathParts.length - 1];
+        alternatives.push(`https://arweave.net/${pathParts[1]}/${filename}`);
+        alternatives.push(`https://arweave.net/${pathParts[1]}`);
+      }
+    }
+    if (url.includes("_") && url.includes(".mp4")) {
+      const encodedUrl = url.replace(/_/g, "%5F");
+      if (encodedUrl !== url) {
+        alternatives.push(encodedUrl);
+      }
+    }
+    if (url.includes(".mp4")) {
+      const urlWithType = url.includes("?") ? `${url}&content-type=video/mp4` : `${url}?content-type=video/mp4`;
+      alternatives.push(urlWithType);
+    }
+  } catch (error) {
+  }
+  return alternatives;
 }
 function convertMarkdownToTelegram(markdown) {
   const replacements = [];
@@ -127,14 +184,36 @@ function convertMarkdownToTelegram(markdown) {
 }
 function convertToTelegramButtons(buttons) {
   if (!buttons) return [];
-  return buttons.map((button) => {
-    switch (button.kind) {
-      case "login":
-        return Markup.button.login(button.text, button.url);
-      case "url":
+  // Flatten if nested, filter nulls/undefined, ensure valid shape
+  const flat = Array.isArray(buttons) 
+    ? (buttons.flat ? buttons.flat() : [].concat(...buttons))
+    : [];
+  
+  return flat
+    .filter(button => button && typeof button === 'object')
+    .map((button) => {
+      // Handle kind-based buttons (legacy)
+      if (button.kind === "login" && button.url) {
+         return Markup.button.login(button.text, button.url);
+      }
+      if (button.kind === "url" && button.url) {
+         return Markup.button.url(button.text, button.url);
+      }
+      // Handle direct url buttons (no kind property)
+      if (button.url && button.text) {
         return Markup.button.url(button.text, button.url);
-    }
-  });
+      }
+      // Handle callback buttons
+      if (button.callback_data && button.text) {
+        return Markup.button.callback(button.text, button.callback_data);
+      }
+      return null; // Invalid button
+    })
+    .filter(b => b !== null); // Remove any nulls from invalid buttons
+}
+function cleanText(text) {
+  if (!text) return "";
+  return text.split("\0").join("");
 }
 
 // src/messageManager.ts
@@ -165,7 +244,6 @@ var MessageManager = class {
     this.bot = bot;
     this.runtime = runtime;
   }
-  // Process image messages and generate descriptions
   /**
    * Process an image from a Telegram message to extract the image URL and description.
    *
@@ -175,12 +253,12 @@ var MessageManager = class {
   async processImage(message) {
     try {
       let imageUrl = null;
-      logger.info(`Telegram Message: ${JSON.stringify(message, null, 2)}`);
+      logger2.info(`Telegram Message: ${JSON.stringify(message, null, 2)}`);
       if ("photo" in message && message.photo?.length > 0) {
         const photo = message.photo[message.photo.length - 1];
         const fileLink = await this.bot.telegram.getFileLink(photo.file_id);
         imageUrl = fileLink.toString();
-      } else if ("document" in message && message.document?.mime_type?.startsWith("image/")) {
+      } else if ("document" in message && message.document?.mime_type?.startsWith("image/") && !message.document?.mime_type?.startsWith("application/pdf")) {
         const fileLink = await this.bot.telegram.getFileLink(message.document.file_id);
         imageUrl = fileLink.toString();
       }
@@ -197,7 +275,262 @@ ${description}]` };
     }
     return null;
   }
-  // Send long messages in chunks
+  /**
+   * Process a document from a Telegram message to extract the document URL and description.
+   * Handles PDFs and other document types by converting them to text when possible.
+   *
+   * @param {Message} message - The Telegram message object containing the document.
+   * @returns {Promise<{ description: string } | null>} The description of the processed document or null if no document found.
+   */
+  async processDocument(message) {
+    try {
+      if (!("document" in message) || !message.document) {
+        return null;
+      }
+      const document = message.document;
+      const fileLink = await this.bot.telegram.getFileLink(document.file_id);
+      const documentUrl = fileLink.toString();
+      logger2.info(
+        `Processing document: ${document.file_name} (${document.mime_type}, ${document.file_size} bytes)`
+      );
+      const documentProcessor = this.getDocumentProcessor(document.mime_type);
+      if (documentProcessor) {
+        return await documentProcessor(document, documentUrl);
+      }
+      return {
+        title: `Document: ${document.file_name || "Unknown Document"}`,
+        fullText: "",
+        formattedDescription: `[Document: ${document.file_name || "Unknown Document"}
+Type: ${document.mime_type || "unknown"}
+Size: ${document.file_size || 0} bytes]`,
+        fileName: document.file_name || "Unknown Document",
+        mimeType: document.mime_type,
+        fileSize: document.file_size
+      };
+    } catch (error) {
+      logger2.error({ error }, "Error processing document");
+      return null;
+    }
+  }
+  /**
+   * Get the appropriate document processor based on MIME type.
+   */
+  getDocumentProcessor(mimeType) {
+    if (!mimeType) return null;
+    const processors = {
+      "application/pdf": this.processPdfDocument.bind(this),
+      "text/": this.processTextDocument.bind(this),
+      // covers text/plain, text/csv, text/markdown, etc.
+      "application/json": this.processTextDocument.bind(this)
+    };
+    for (const [pattern, processor] of Object.entries(processors)) {
+      if (mimeType.startsWith(pattern)) {
+        return processor;
+      }
+    }
+    return null;
+  }
+  /**
+   * Process PDF documents by converting them to text.
+   */
+  async processPdfDocument(document, documentUrl) {
+    try {
+      const pdfService = this.runtime.getService(ServiceType.PDF);
+      if (!pdfService) {
+        logger2.warn("PDF service not available, using fallback");
+        return {
+          title: `PDF Document: ${document.file_name || "Unknown Document"}`,
+          fullText: "",
+          formattedDescription: `[PDF Document: ${document.file_name || "Unknown Document"}
+Size: ${document.file_size || 0} bytes
+Unable to extract text content]`,
+          fileName: document.file_name || "Unknown Document",
+          mimeType: document.mime_type,
+          fileSize: document.file_size
+        };
+      }
+      const response = await fetch(documentUrl);
+      if (!response.ok) {
+        throw new Error(`Failed to fetch PDF: ${response.status}`);
+      }
+      const pdfBuffer = await response.arrayBuffer();
+      const text = await pdfService.convertPdfToText(Buffer.from(pdfBuffer));
+      logger2.info(`PDF processed successfully: ${text.length} characters extracted`);
+      return {
+        title: document.file_name || "Unknown Document",
+        fullText: text,
+        formattedDescription: `[PDF Document: ${document.file_name || "Unknown Document"}
+Size: ${document.file_size || 0} bytes
+Text extracted successfully: ${text.length} characters]`,
+        fileName: document.file_name || "Unknown Document",
+        mimeType: document.mime_type,
+        fileSize: document.file_size
+      };
+    } catch (error) {
+      logger2.error({ error }, "Error processing PDF document");
+      return {
+        title: `PDF Document: ${document.file_name || "Unknown Document"}`,
+        fullText: "",
+        formattedDescription: `[PDF Document: ${document.file_name || "Unknown Document"}
+Size: ${document.file_size || 0} bytes
+Error: Unable to extract text content]`,
+        fileName: document.file_name || "Unknown Document",
+        mimeType: document.mime_type,
+        fileSize: document.file_size
+      };
+    }
+  }
+  /**
+   * Process text documents by fetching their content.
+   */
+  async processTextDocument(document, documentUrl) {
+    try {
+      const response = await fetch(documentUrl);
+      if (!response.ok) {
+        throw new Error(`Failed to fetch text document: ${response.status}`);
+      }
+      const text = await response.text();
+      logger2.info(`Text document processed successfully: ${text.length} characters extracted`);
+      return {
+        title: document.file_name || "Unknown Document",
+        fullText: text,
+        formattedDescription: `[Text Document: ${document.file_name || "Unknown Document"}
+Size: ${document.file_size || 0} bytes
+Text extracted successfully: ${text.length} characters]`,
+        fileName: document.file_name || "Unknown Document",
+        mimeType: document.mime_type,
+        fileSize: document.file_size
+      };
+    } catch (error) {
+      logger2.error({ error }, "Error processing text document");
+      return {
+        title: `Text Document: ${document.file_name || "Unknown Document"}`,
+        fullText: "",
+        formattedDescription: `[Text Document: ${document.file_name || "Unknown Document"}
+Size: ${document.file_size || 0} bytes
+Error: Unable to read content]`,
+        fileName: document.file_name || "Unknown Document",
+        mimeType: document.mime_type,
+        fileSize: document.file_size
+      };
+    }
+  }
+  /**
+   * Processes the message content, documents, and images to generate
+   * processed content and media attachments.
+   *
+   * @param {Message} message The message to process
+   * @returns {Promise<{ processedContent: string; attachments: Media[] }>} Processed content and media attachments
+   */
+  async processMessage(message) {
+    let processedContent = "";
+    let attachments = [];
+    if ("text" in message && message.text) {
+      processedContent = message.text;
+    } else if ("caption" in message && message.caption) {
+      processedContent = message.caption;
+    }
+    if ("document" in message && message.document) {
+      const document = message.document;
+      const documentInfo = await this.processDocument(message);
+      if (documentInfo) {
+        try {
+          const fileLink = await this.bot.telegram.getFileLink(document.file_id);
+          const title = documentInfo.title;
+          const fullText = documentInfo.fullText;
+          if (fullText) {
+            const documentContent = `
+
+--- DOCUMENT CONTENT ---
+Title: ${title}
+
+Full Content:
+${fullText}
+--- END DOCUMENT ---
+
+`;
+            processedContent += documentContent;
+          }
+          attachments.push({
+            id: document.file_id,
+            url: fileLink.toString(),
+            title,
+            source: document.mime_type?.startsWith("application/pdf") ? "PDF" : "Document",
+            description: documentInfo.formattedDescription,
+            text: fullText
+          });
+          logger2.info(`Document processed successfully: ${documentInfo.fileName}`);
+        } catch (error) {
+          logger2.error({ error }, `Error processing document ${documentInfo.fileName}`);
+          attachments.push({
+            id: document.file_id,
+            url: "",
+            title: `Document: ${documentInfo.fileName}`,
+            source: "Document",
+            description: `Document processing failed: ${documentInfo.fileName}`,
+            text: `Document: ${documentInfo.fileName}
+Size: ${documentInfo.fileSize || 0} bytes
+Type: ${documentInfo.mimeType || "unknown"}`
+          });
+        }
+      } else {
+        attachments.push({
+          id: document.file_id,
+          url: "",
+          title: `Document: ${document.file_name || "Unknown Document"}`,
+          source: "Document",
+          description: `Document: ${document.file_name || "Unknown Document"}`,
+          text: `Document: ${document.file_name || "Unknown Document"}
+Size: ${document.file_size || 0} bytes
+Type: ${document.mime_type || "unknown"}`
+        });
+      }
+    }
+    if ("photo" in message && message.photo?.length > 0) {
+      const imageInfo = await this.processImage(message);
+      if (imageInfo) {
+        const photo = message.photo[message.photo.length - 1];
+        const fileLink = await this.bot.telegram.getFileLink(photo.file_id);
+        attachments.push({
+          id: photo.file_id,
+          url: fileLink.toString(),
+          title: "Image Attachment",
+          source: "Image",
+          description: imageInfo.description,
+          text: imageInfo.description
+        });
+      }
+    }
+    if ("animation" in message && message.animation) {
+      const animation = message.animation;
+      const fileLink = await this.bot.telegram.getFileLink(animation.file_id);
+      let thumbnailUrl = null;
+      
+      // Get thumbnail if available
+      if (animation.thumbnail && animation.thumbnail.file_id) {
+        try {
+          const thumbLink = await this.bot.telegram.getFileLink(animation.thumbnail.file_id);
+          thumbnailUrl = thumbLink.toString();
+        } catch (thumbError) {
+          logger2.warn('Failed to get animation thumbnail', thumbError);
+        }
+      }
+      
+      attachments.push({
+        id: animation.file_id,
+        url: fileLink.toString(),
+        title: animation.file_name || "Animation",
+        source: "Animation",
+        description: `Animation: ${animation.file_name || 'file'}`,
+        text: `Animation: ${animation.file_name || 'file'}`,
+        thumbnailUrl: thumbnailUrl // Custom field for /fv to use
+      });
+    }
+    logger2.info(
+      `\n━━━━━━━━━━ Message processed ━━━━━━━━━━ Content: ${processedContent ? "yes" : "no"}, Attachments: ${attachments.length}`
+    );
+    return { processedContent, attachments };
+  }
   /**
    * Sends a message in chunks, handling attachments and splitting the message if necessary
    *
@@ -207,43 +540,308 @@ ${description}]` };
    * @returns {Promise<Message.TextMessage[]>} - An array of TextMessage objects representing the messages sent
    */
   async sendMessageInChunks(ctx, content, replyToMessageId) {
+    // FIX: properly await attachments and use native Telegram media methods for inline preview
     if (content.attachments && content.attachments.length > 0) {
-      content.attachments.map(async (attachment) => {
-        const typeMap = {
-          "image/gif": "animation" /* ANIMATION */,
-          image: "photo" /* PHOTO */,
-          doc: "document" /* DOCUMENT */,
-          video: "video" /* VIDEO */,
-          audio: "audio" /* AUDIO */
-        };
-        let mediaType = void 0;
-        for (const prefix in typeMap) {
-          if (attachment.contentType?.startsWith(prefix)) {
-            mediaType = typeMap[prefix];
+      // Convert buttons for later use
+      const telegramButtons = convertToTelegramButtons(content.buttons ?? []);
+      const hasButtons = telegramButtons && telegramButtons.length > 0;
+      
+      // Use awaited for-loop instead of map(async...) to ensure media sends complete
+      let sentPrimaryMedia = false;
+      for (const attachment of content.attachments) {
+        if (sentPrimaryMedia) break;
+        const url = attachment.url || attachment.href || "";
+        const ct = (attachment.contentType || "").toLowerCase();
+        const isVideo = /^video\//.test(ct) || /\.mp4(\?|$)/i.test(url);
+        const isGif = ct === "image/gif" || /\.gif(\?|$)/i.test(url);
+        const isImage = /^image\//.test(ct) || /\.(png|jpe?g|webp)(\?|$)/i.test(url);
+        
+        // Route to Telegram media methods for inline preview/player
+        if (isVideo) {
+          // Attempt streaming first for Arweave/S3 hosts
+          let streamingFirst = false;
+          try {
+            const host = new URL(url).hostname;
+            streamingFirst = /arweave\.net$/i.test(host) || /amazonaws\.com$/i.test(host) || /tokenscan\.io$/i.test(host);
+          } catch {}
+          if (streamingFirst) {
+            try {
+              const head = await fetch(url, { method: 'HEAD' });
+              const lenStr = head.ok ? head.headers.get('content-length') : null;
+              const maxBytes = 49 * 1024 * 1024; // ~49MB for bot upload
+              const length = lenStr ? parseInt(lenStr, 10) : NaN;
+              if (!Number.isNaN(length) && length > maxBytes) {
+                throw new Error('FileTooLargeForBotUpload');
+              }
+              const response = await fetch(url);
+              if (response && response.ok) {
+                const ab = await response.arrayBuffer();
+                const filename = (() => {
+                  try {
+                    const u = new URL(url);
+                    const last = u.pathname.split('/').pop() || '';
+                    return last && last.length <= 100 ? last : 'video.mp4';
+                  } catch (_) {
+                    return 'video.mp4';
+                  }
+                })();
+                await ctx.replyWithVideo({ source: Buffer.from(ab), filename }, {
+                  caption: content.text || undefined,
+                  supports_streaming: true,
+                  reply_parameters: replyToMessageId ? { message_id: replyToMessageId } : undefined,
+                  ...Markup2.inlineKeyboard(telegramButtons)
+                });
+                sentPrimaryMedia = true;
+                break;
+              }
+            } catch (videoStreamFirstErr) {
+              logger2.warn({ url, videoStreamFirstErr }, "Video streaming-first failed, trying URL send");
+            }
+          }
+          try {
+            await ctx.replyWithVideo(url, {
+              caption: content.text || undefined,
+              // Don't use parse_mode for captions - plain text avoids escaping issues
+              supports_streaming: true,
+              reply_parameters: replyToMessageId ? { message_id: replyToMessageId } : undefined,
+              ...Markup2.inlineKeyboard(telegramButtons)
+            });
+            sentPrimaryMedia = true;
             break;
+          } catch (videoErr) {
+            // Try alternative URL variants first (Arweave quirks)
+            try {
+              const alternatives = [url, ...generateAlternativeUrls(url)];
+              let sent = false;
+              for (const alt of alternatives) {
+                try {
+                  await ctx.replyWithVideo(alt, {
+                    caption: content.text || undefined,
+                    supports_streaming: true,
+                    reply_parameters: replyToMessageId ? { message_id: replyToMessageId } : undefined,
+                    ...Markup2.inlineKeyboard(telegramButtons)
+                  });
+                  sent = true;
+                  sentPrimaryMedia = true;
+                  break;
+                } catch {}
+              }
+              if (sent) {
+                break;
+              }
+            } catch {}
+
+            // Fallback 2: send as document using alternatives
+            try {
+              const alternatives = [url, ...generateAlternativeUrls(url)];
+              let sentDoc = false;
+              for (const alt of alternatives) {
+                try {
+                  await ctx.replyWithDocument(alt, {
+                    caption: content.text || undefined,
+                    reply_parameters: replyToMessageId ? { message_id: replyToMessageId } : undefined,
+                    ...Markup2.inlineKeyboard(telegramButtons)
+                  });
+                  sentDoc = true;
+                  sentPrimaryMedia = true;
+                  break;
+                } catch {}
+              }
+              if (sentDoc) {
+                break;
+              }
+            } catch {}
+
+            // Final fallback: stream-download and upload as file to Telegram (size-checked)
+            try {
+              const head = await fetch(url, { method: 'HEAD' });
+              const lenStr = head.ok ? head.headers.get('content-length') : null;
+              const maxBytes = 48 * 1024 * 1024; // ~48MB safety for bot limit
+              const length = lenStr ? parseInt(lenStr, 10) : NaN;
+              if (!Number.isNaN(length) && length > maxBytes) {
+                throw new Error('FileTooLargeForBotUpload');
+              }
+              const response = await fetch(url);
+              if (response && response.ok) {
+                const ab = await response.arrayBuffer();
+                const filename = (() => {
+                  try {
+                    const u = new URL(url);
+                    const last = u.pathname.split('/').pop() || '';
+                    return last && last.length <= 100 ? last : 'video.mp4';
+                  } catch (_) {
+                    return 'video.mp4';
+                  }
+                })();
+                await ctx.replyWithVideo({ source: Buffer.from(ab), filename }, {
+                  caption: content.text || undefined,
+                  supports_streaming: true,
+                  reply_parameters: replyToMessageId ? { message_id: replyToMessageId } : undefined,
+                  ...Markup2.inlineKeyboard(telegramButtons)
+                });
+                sentPrimaryMedia = true;
+                break;
+              }
+            } catch (streamErr) {
+              logger2.warn({ videoErr, url, streamErr }, "Video attachment failed after streaming fallback, sending text link");
+            }
           }
         }
-        if (!mediaType) {
-          throw new Error(
-            `Unsupported Telegram attachment content type: ${attachment.contentType}`
-          );
+        
+        if (isGif) {
+          try {
+            await ctx.replyWithAnimation(url, {
+              caption: content.text || undefined,
+              reply_parameters: replyToMessageId ? { message_id: replyToMessageId } : undefined,
+              ...Markup2.inlineKeyboard(telegramButtons)
+            });
+            sentPrimaryMedia = true;
+            break;
+          } catch (gifErr) {
+            // Stream fallback for GIF
+            try {
+              const head = await fetch(url, { method: 'HEAD' });
+              const lenStr = head.ok ? head.headers.get('content-length') : null;
+              const maxBytes = 20 * 1024 * 1024; // 20MB safety for animations
+              const length = lenStr ? parseInt(lenStr, 10) : NaN;
+              if (!Number.isNaN(length) && length > maxBytes) {
+                throw new Error('GifTooLargeForBotUpload');
+              }
+              const resp = await fetch(url);
+              if (resp && resp.ok) {
+                const ab = await resp.arrayBuffer();
+                const filename = (() => {
+                  try {
+                    const u = new URL(url);
+                    const last = u.pathname.split('/').pop() || '';
+                    return last && last.length <= 100 ? last : 'animation.gif';
+                  } catch (_) {
+                    return 'animation.gif';
+                  }
+                })();
+                await ctx.replyWithAnimation({ source: Buffer.from(ab), filename }, {
+                  caption: content.text || undefined,
+                  reply_parameters: replyToMessageId ? { message_id: replyToMessageId } : undefined,
+                  ...Markup2.inlineKeyboard(telegramButtons)
+                });
+                sentPrimaryMedia = true;
+                break;
+              }
+            } catch (gifStreamErr) {
+              logger2.warn({ gifErr, gifStreamErr, url }, "GIF attachment failed after streaming fallback");
+            }
+          }
         }
-        await this.sendMedia(ctx, attachment.url, mediaType, attachment.description);
-      });
+        
+        if (isImage) {
+          try {
+            await ctx.replyWithPhoto(url, {
+              caption: content.text || undefined,
+              reply_parameters: replyToMessageId ? { message_id: replyToMessageId } : undefined,
+              ...Markup2.inlineKeyboard(telegramButtons)
+            });
+            sentPrimaryMedia = true;
+            break;
+          } catch (photoErr) {
+            // Stream fallback for image
+            try {
+              const head = await fetch(url, { method: 'HEAD' });
+              const lenStr = head.ok ? head.headers.get('content-length') : null;
+              const maxBytes = 10 * 1024 * 1024; // 10MB safety for images
+              const length = lenStr ? parseInt(lenStr, 10) : NaN;
+              if (!Number.isNaN(length) && length > maxBytes) {
+                throw new Error('ImageTooLargeForBotUpload');
+              }
+              const resp = await fetch(url);
+              if (resp && resp.ok) {
+                const ab = await resp.arrayBuffer();
+                const filename = (() => {
+                  try {
+                    const u = new URL(url);
+                    const last = u.pathname.split('/').pop() || '';
+                    return last && last.length <= 100 ? last : 'image.jpg';
+                  } catch (_) {
+                    return 'image.jpg';
+                  }
+                })();
+                await ctx.replyWithPhoto({ source: Buffer.from(ab), filename }, {
+                  caption: content.text || undefined,
+                  reply_parameters: replyToMessageId ? { message_id: replyToMessageId } : undefined,
+                  ...Markup2.inlineKeyboard(telegramButtons)
+                });
+                sentPrimaryMedia = true;
+                break;
+              }
+            } catch (photoStreamErr) {
+              logger2.warn({ photoErr, photoStreamErr, url }, "Photo attachment failed after streaming fallback");
+            }
+          }
+        }
+        
+        // Fallback: send as document for unsupported types
+        try {
+          await ctx.replyWithDocument(url, {
+            caption: content.text || undefined,
+            reply_parameters: replyToMessageId ? { message_id: replyToMessageId } : undefined,
+            ...Markup2.inlineKeyboard(telegramButtons)
+          });
+          sentPrimaryMedia = true;
+          break;
+        } catch (docErr) {
+          // Stream fallback for generic document when size is reasonable
+          try {
+            const head = await fetch(url, { method: 'HEAD' });
+            const lenStr = head.ok ? head.headers.get('content-length') : null;
+            const maxBytes = 20 * 1024 * 1024; // 20MB safety
+            const length = lenStr ? parseInt(lenStr, 10) : NaN;
+            if (!Number.isNaN(length) && length > maxBytes) {
+              throw new Error('DocTooLargeForBotUpload');
+            }
+            const resp = await fetch(url);
+            if (resp && resp.ok) {
+              const ab = await resp.arrayBuffer();
+              const filename = (() => {
+                try {
+                  const u = new URL(url);
+                  const last = u.pathname.split('/').pop() || '';
+                  return last && last.length <= 100 ? last : 'file.bin';
+                } catch (_) {
+                  return 'file.bin';
+                }
+              })();
+              await ctx.replyWithDocument({ source: Buffer.from(ab), filename }, {
+                caption: content.text || undefined,
+                reply_parameters: replyToMessageId ? { message_id: replyToMessageId } : undefined,
+                ...Markup2.inlineKeyboard(telegramButtons)
+              });
+              sentPrimaryMedia = true;
+              break;
+            }
+          } catch (docStreamErr) {
+            logger2.warn({ docErr, docStreamErr, url }, "Document attachment failed after streaming fallback");
+          }
+        }
+      }
+      
+      // If we have buttons but no text, send them separately
+      if (hasButtons && !content.text) {
+        await ctx.reply("", Markup2.inlineKeyboard(telegramButtons));
+      }
+      
       return [];
     } else {
       const chunks = this.splitMessage(content.text ?? "");
       const sentMessages = [];
       const telegramButtons = convertToTelegramButtons(content.buttons ?? []);
       if (!ctx.chat) {
-        logger.error("sendMessageInChunks: ctx.chat is undefined");
+        logger2.error("sendMessageInChunks: ctx.chat is undefined");
         return [];
       }
       await ctx.telegram.sendChatAction(ctx.chat.id, "typing");
       for (let i = 0; i < chunks.length; i++) {
         const chunk = convertMarkdownToTelegram(chunks[i]);
         if (!ctx.chat) {
-          logger.error("sendMessageInChunks loop: ctx.chat is undefined");
+          logger2.error("sendMessageInChunks loop: ctx.chat is undefined");
           continue;
         }
         const sentMessage = await ctx.telegram.sendMessage(ctx.chat.id, chunk, {
@@ -284,7 +882,47 @@ ${description}]` };
         throw new Error("sendMedia: ctx.chat is undefined");
       }
       if (isUrl) {
-        await sendFunction(ctx.chat.id, mediaPath, { caption });
+        const encodedMediaPath = encodeUrlForTelegram(mediaPath);
+        try {
+          await sendFunction(ctx.chat.id, encodedMediaPath, { caption });
+        } catch (error) {
+          if (isProblematicVideoUrl(mediaPath)) {
+            logger2.warn(`Video URL failed, trying alternative formats: ${mediaPath}`);
+            const alternativeUrls = generateAlternativeUrls(mediaPath);
+            let success = false;
+            for (const altUrl of alternativeUrls) {
+              try {
+                const encodedAltUrl = encodeUrlForTelegram(altUrl);
+                await sendFunction(ctx.chat.id, encodedAltUrl, { caption });
+                success = true;
+                logger2.info(`Successfully sent video using alternative URL: ${altUrl}`);
+                break;
+              } catch (altError) {
+                logger2.debug(`Alternative URL also failed: ${altUrl}`);
+                continue;
+              }
+            }
+            if (!success) {
+              logger2.warn(`All video alternatives failed, trying as document: ${mediaPath}`);
+              try {
+                await ctx.telegram.sendDocument(ctx.chat.id, mediaPath, { caption });
+                success = true;
+                logger2.info(`Successfully sent as document: ${mediaPath}`);
+              } catch (docError) {
+                logger2.error(`Document send also failed: ${docError}`);
+              }
+            }
+            if (!success) {
+              const fallbackText = (caption ? caption + "\n\n" : "") + "\u{1F3AC} Video: " + mediaPath;
+              await ctx.telegram.sendMessage(ctx.chat.id, fallbackText, {
+                link_preview_options: { is_disabled: false }
+              });
+              logger2.info(`Sent video as text link: ${mediaPath}`);
+            }
+          } else {
+            throw error;
+          }
+        }
       } else {
         if (!fs.existsSync(mediaPath)) {
           throw new Error(`File not found at path: ${mediaPath}`);
@@ -299,19 +937,18 @@ ${description}]` };
           fileStream.destroy();
         }
       }
-      logger.info(
+      logger2.info(
         `${type.charAt(0).toUpperCase() + type.slice(1)} sent successfully: ${mediaPath}`
       );
     } catch (error) {
       const errorMessage = error instanceof Error ? error.message : String(error);
-      logger.error(
+      logger2.error(
         { originalError: error },
         `Failed to send ${type}. Path: ${mediaPath}. Error: ${errorMessage}`
       );
       throw error;
     }
   }
-  // Split message into smaller parts
   /**
    * Splits a given text into an array of strings based on the maximum message length.
    *
@@ -334,7 +971,6 @@ ${description}]` };
     if (currentChunk) chunks.push(currentChunk);
     return chunks;
   }
-  // Main handler for incoming messages
   /**
    * Handle incoming messages from Telegram and process them accordingly.
    * @param {Context} ctx - The context object containing information about the message.
@@ -347,21 +983,23 @@ ${description}]` };
       const entityId = createUniqueUuid(this.runtime, ctx.from.id.toString());
       const threadId = "is_topic_message" in message && message.is_topic_message ? message.message_thread_id?.toString() : void 0;
       if (!ctx.chat) {
-        logger.error("handleMessage: ctx.chat is undefined");
+        logger2.error("handleMessage: ctx.chat is undefined");
         return;
       }
       const telegramRoomid = threadId ? `${ctx.chat.id}-${threadId}` : ctx.chat.id.toString();
       const roomId = createUniqueUuid(this.runtime, telegramRoomid);
       const messageId = createUniqueUuid(this.runtime, message?.message_id?.toString());
-      const imageInfo = await this.processImage(message);
-      let messageText = "";
-      if ("text" in message && message.text) {
-        messageText = message.text;
-      } else if ("caption" in message && message.caption) {
-        messageText = message.caption;
+      const { processedContent, attachments } = await this.processMessage(message);
+      const cleanedContent = cleanText(processedContent);
+      const cleanedAttachments = attachments.map((att) => ({
+        ...att,
+        text: cleanText(att.text),
+        description: cleanText(att.description),
+        title: cleanText(att.title)
+      }));
+      if (!cleanedContent && cleanedAttachments.length === 0) {
+        return;
       }
-      const fullText = imageInfo ? `${messageText} ${imageInfo.description}` : messageText;
-      if (!fullText) return;
       const chat = message.chat;
       const channelType = getChannelType(chat);
       const sourceId = createUniqueUuid(this.runtime, "" + chat.id);
@@ -383,10 +1021,9 @@ ${description}]` };
         agentId: this.runtime.agentId,
         roomId,
         content: {
-          text: fullText,
-          // attachments?
+          text: cleanedContent || " ",
+          attachments: cleanedAttachments,
           source: "telegram",
-          // url?
           channelType,
           inReplyTo: "reply_to_message" in message && message.reply_to_message ? createUniqueUuid(this.runtime, message.reply_to_message.message_id.toString()) : void 0
         },
@@ -442,26 +1079,55 @@ ${description}]` };
           }
           return memories;
         } catch (error) {
-          logger.error({ error }, "Error in message callback");
+          logger2.error({ error }, "Error in message callback");
           return [];
         }
       };
-      this.runtime.emitEvent(EventType.MESSAGE_RECEIVED, {
-        runtime: this.runtime,
-        message: memory,
-        callback,
-        source: "telegram"
-      });
-      this.runtime.emitEvent("TELEGRAM_MESSAGE_RECEIVED" /* MESSAGE_RECEIVED */, {
-        runtime: this.runtime,
-        message: memory,
-        callback,
-        source: "telegram",
-        ctx,
-        originalMessage: message
-      });
+      // Emit MESSAGE_RECEIVED so custom plugins can intercept
+      try {
+        await this.runtime.emitEvent("MESSAGE_RECEIVED", {
+          runtime: this.runtime,
+          message: memory,
+          callback,
+          source: "telegram",
+          ctx
+        });
+      } catch (e) {}
+
+      // Skip bootstrap/messageService if a plugin already handled it
+      if ((memory?.metadata)?.__handledByCustom) {
+        return;
+      }
+
+      // Skip bootstrap if this is a reply to someone OTHER than the bot
+      if ("reply_to_message" in message && message.reply_to_message) {
+        const replyToUserId = message.reply_to_message.from?.id;
+        const botUserId = this.bot.botInfo?.id;
+        if (replyToUserId && botUserId && replyToUserId !== botUserId) {
+          // This is a reply to another user, not the bot - skip bootstrap
+          logger2.debug(`Skipping bootstrap for reply to user ${replyToUserId} (not bot ${botUserId})`);
+          return;
+        }
+      }
+
+      if (!this.runtime.messageService) {
+        logger2.error("Message service is not available");
+        throw new Error(
+          "Message service is not initialized. Ensure the message service is properly configured."
+        );
+      }
+      
+      // Build mentionContext so bootstrap knows this is a reply/mention
+      const isMention = message.text?.includes(`@${this.bot.botInfo?.username}`);
+      const isReplyToBot = message.reply_to_message?.from?.id === this.bot.botInfo?.id;
+      const mentionContext = (isMention || isReplyToBot) ? {
+        isMention: !!isMention,
+        isReply: !!isReplyToBot
+      } : undefined;
+      
+      await this.runtime.messageService.handleMessage(this.runtime, memory, callback, mentionContext);
     } catch (error) {
-      logger.error(
+      logger2.error(
         {
           error,
           chatId: ctx.chat?.id,
@@ -527,7 +1193,7 @@ ${description}]` };
           };
           return [responseMemory];
         } catch (error) {
-          logger.error({ error }, "Error in reaction callback");
+          logger2.error({ error }, "Error in reaction callback");
           return [];
         }
       };
@@ -555,7 +1221,7 @@ ${description}]` };
       });
     } catch (error) {
       const errorMessage = error instanceof Error ? error.message : String(error);
-      logger.error(
+      logger2.error(
         {
           error: errorMessage,
           originalError: error
@@ -621,7 +1287,7 @@ ${description}]` };
       return sentMessages;
     } catch (error) {
       const errorMessage = error instanceof Error ? error.message : String(error);
-      logger.error(
+      logger2.error(
         {
           error: errorMessage,
           originalError: error
@@ -648,10 +1314,10 @@ var TelegramService = class _TelegramService extends Service {
    */
   constructor(runtime) {
     super(runtime);
-    logger2.log("\u{1F4F1} Constructing new TelegramService...");
+    logger3.log("\u{1F4F1} Constructing new TelegramService...");
     const botToken = runtime.getSetting("TELEGRAM_BOT_TOKEN");
     if (!botToken || botToken.trim() === "") {
-      logger2.warn("Telegram Bot Token not provided - Telegram functionality will be unavailable");
+      logger3.warn("Telegram Bot Token not provided - Telegram functionality will be unavailable");
       this.bot = null;
       this.messageManager = null;
       return;
@@ -664,9 +1330,9 @@ var TelegramService = class _TelegramService extends Service {
     try {
       this.bot = new Telegraf(botToken, this.options);
       this.messageManager = new MessageManager(this.bot, this.runtime);
-      logger2.log("\u2705 TelegramService constructor completed");
+      logger3.log("\u2705 TelegramService constructor completed");
     } catch (error) {
-      logger2.error(
+      logger3.error(
         `Error initializing Telegram bot: ${error instanceof Error ? error.message : String(error)}`
       );
       this.bot = null;
@@ -682,7 +1348,7 @@ var TelegramService = class _TelegramService extends Service {
   static async start(runtime) {
     const service = new _TelegramService(runtime);
     if (!service.bot) {
-      logger2.warn("Telegram service started without bot functionality - no bot token provided");
+      logger3.warn("Telegram service started without bot functionality - no bot token provided");
       return service;
     }
     const maxRetries = 5;
@@ -690,10 +1356,10 @@ var TelegramService = class _TelegramService extends Service {
     let lastError = null;
     while (retryCount < maxRetries) {
       try {
-        logger2.success(
+        logger3.success(
           `\u2705 Telegram client successfully started for character ${runtime.character.name}`
         );
-        logger2.log("\u{1F680} Starting Telegram bot...");
+        logger3.log("\u{1F680} Starting Telegram bot...");
         await service.initializeBot();
         service.setupMiddlewares();
         service.setupMessageHandlers();
@@ -701,18 +1367,18 @@ var TelegramService = class _TelegramService extends Service {
         return service;
       } catch (error) {
         lastError = error instanceof Error ? error : new Error(String(error));
-        logger2.error(
+        logger3.error(
           `Telegram initialization attempt ${retryCount + 1} failed: ${lastError.message}`
         );
         retryCount++;
         if (retryCount < maxRetries) {
           const delay = 2 ** retryCount * 1e3;
-          logger2.info(`Retrying Telegram initialization in ${delay / 1e3} seconds...`);
+          logger3.info(`Retrying Telegram initialization in ${delay / 1e3} seconds...`);
           await new Promise((resolve) => setTimeout(resolve, delay));
         }
       }
     }
-    logger2.error(
+    logger3.error(
       `Telegram initialization failed after ${maxRetries} attempts. Last error: ${lastError?.message}. Service will continue without Telegram functionality.`
     );
     return service;
@@ -751,7 +1417,7 @@ var TelegramService = class _TelegramService extends Service {
       allowedUpdates: ["message", "message_reaction"]
     });
     const botInfo = await this.bot.telegram.getMe();
-    logger2.log(`Bot info: ${JSON.stringify(botInfo)}`);
+    logger3.log(`Bot info: ${JSON.stringify(botInfo)}`);
     process.once("SIGINT", () => this.bot?.stop("SIGINT"));
     process.once("SIGTERM", () => this.bot?.stop("SIGTERM"));
   }
@@ -785,7 +1451,7 @@ var TelegramService = class _TelegramService extends Service {
    */
   async authorizationMiddleware(ctx, next) {
     if (!await this.isGroupAuthorized(ctx)) {
-      logger2.debug("Chat not authorized, skipping message processing");
+      logger3.debug("Chat not authorized, skipping message processing");
       return;
     }
     await next();
@@ -825,7 +1491,7 @@ var TelegramService = class _TelegramService extends Service {
       try {
         await this.handleForumTopic(ctx);
       } catch (error) {
-        logger2.error({ error }, `Error handling forum topic: ${error}`);
+        logger3.error({ error }, `Error handling forum topic: ${error}`);
       }
     }
     if (ctx.from && ctx.chat.type !== "private") {
@@ -843,14 +1509,14 @@ var TelegramService = class _TelegramService extends Service {
       try {
         await this.messageManager.handleMessage(ctx);
       } catch (error) {
-        logger2.error({ error }, "Error handling message");
+        logger3.error({ error }, "Error handling message");
       }
     });
     this.bot?.on("message_reaction", async (ctx) => {
       try {
         await this.messageManager.handleReaction(ctx);
       } catch (error) {
-        logger2.error({ error }, "Error handling reaction");
+        logger3.error({ error }, "Error handling reaction");
       }
     });
   }
@@ -870,7 +1536,7 @@ var TelegramService = class _TelegramService extends Service {
       const allowedChatsList = JSON.parse(allowedChats);
       return allowedChatsList.includes(chatId);
     } catch (error) {
-      logger2.error({ error }, "Error parsing TELEGRAM_ALLOWED_CHATS");
+      logger3.error({ error }, "Error parsing TELEGRAM_ALLOWED_CHATS");
       return false;
     }
   }
@@ -1059,7 +1725,7 @@ var TelegramService = class _TelegramService extends Service {
         );
         owner = foundOwner || null;
       } catch (error) {
-        logger2.warn(
+        logger3.warn(
           `Could not get chat administrators: ${error instanceof Error ? error.message : String(error)}`
         );
       }
@@ -1172,13 +1838,13 @@ var TelegramService = class _TelegramService extends Service {
                 worldId
               });
             } else {
-              logger2.warn(
+              logger3.warn(
                 `Skipping entity sync due to missing ID: ${JSON.stringify(entity.names)}`
               );
             }
           } catch (err) {
             const telegramMetadata = entity.metadata?.telegram;
-            logger2.warn(`Failed to sync user ${telegramMetadata?.username}: ${err}`);
+            logger3.warn(`Failed to sync user ${telegramMetadata?.username}: ${err}`);
           }
         })
       );
@@ -1274,11 +1940,11 @@ var TelegramService = class _TelegramService extends Service {
             }
           }
         } catch (error) {
-          logger2.warn(`Could not fetch administrators for chat ${chat.id}: ${error}`);
+          logger3.warn(`Could not fetch administrators for chat ${chat.id}: ${error}`);
         }
       }
     } catch (error) {
-      logger2.error(
+      logger3.error(
         `Error building standardized entities: ${error instanceof Error ? error.message : String(error)}`
       );
     }
@@ -1330,7 +1996,7 @@ var TelegramService = class _TelegramService extends Service {
       };
       return room;
     } catch (error) {
-      logger2.error(
+      logger3.error(
         `Error building forum topic room: ${error instanceof Error ? error.message : String(error)}`
       );
       return null;
@@ -1342,14 +2008,14 @@ var TelegramService = class _TelegramService extends Service {
         "telegram",
         serviceInstance.handleSendMessage.bind(serviceInstance)
       );
-      logger2.info("[Telegram] Registered send handler.");
+      logger3.info("[Telegram] Registered send handler.");
     } else {
-      logger2.warn("[Telegram] Cannot register send handler - bot not initialized.");
+      logger3.warn("[Telegram] Cannot register send handler - bot not initialized.");
     }
   }
   async handleSendMessage(runtime, target, content) {
     if (!this.bot || !this.messageManager) {
-      logger2.error("[Telegram SendHandler] Bot not initialized - cannot send messages.");
+      logger3.error("[Telegram SendHandler] Bot not initialized - cannot send messages.");
       throw new Error("Telegram bot is not initialized. Please provide TELEGRAM_BOT_TOKEN.");
     }
     let chatId;
@@ -1361,7 +2027,7 @@ var TelegramService = class _TelegramService extends Service {
       if (!chatId)
         throw new Error(`Could not resolve Telegram chat ID from roomId ${target.roomId}`);
     } else if (target.entityId) {
-      logger2.error("[Telegram SendHandler] Sending DMs via entityId not implemented yet.");
+      logger3.error("[Telegram SendHandler] Sending DMs via entityId not implemented yet.");
       throw new Error("Sending DMs via entityId is not yet supported for Telegram.");
     } else {
       throw new Error("Telegram SendHandler requires channelId, roomId, or entityId.");
@@ -1373,9 +2039,9 @@ var TelegramService = class _TelegramService extends Service {
     }
     try {
       await this.messageManager.sendMessage(chatId, content);
-      logger2.info(`[Telegram SendHandler] Message sent to chat ID: ${chatId}`);
+      logger3.info(`[Telegram SendHandler] Message sent to chat ID: ${chatId}`);
     } catch (error) {
-      logger2.error(
+      logger3.error(
         {
           target,
           content
@@ -1388,7 +2054,7 @@ var TelegramService = class _TelegramService extends Service {
 };
 
 // src/tests.ts
-import { logger as logger3 } from "@elizaos/core";
+import { logger as logger4 } from "@elizaos/core";
 var TEST_IMAGE_URL = "https://github.com/elizaOS/awesome-eliza/blob/main/assets/eliza-logo.jpg?raw=true";
 var TelegramTestSuite = class {
   name = "telegram";
@@ -1457,7 +2123,7 @@ var TelegramTestSuite = class {
         throw new Error("Bot is not initialized.");
       }
       const chat = await this.bot.telegram.getChat(chatId);
-      logger3.log(`Fetched real chat: ${JSON.stringify(chat)}`);
+      logger4.log(`Fetched real chat: ${JSON.stringify(chat)}`);
       return chat;
     } catch (error) {
       throw new Error(`Error fetching real Telegram chat: ${error}`);
@@ -1472,14 +2138,14 @@ var TelegramTestSuite = class {
     }
     this.bot = this.telegramClient.messageManager.bot;
     this.messageManager = this.telegramClient.messageManager;
-    logger3.debug("Telegram bot initialized successfully.");
+    logger4.debug("Telegram bot initialized successfully.");
   }
   async testSendingTextMessage(runtime) {
     try {
       if (!this.bot) throw new Error("Bot not initialized.");
       const chatId = this.validateChatId(runtime);
       await this.bot.telegram.sendMessage(chatId, "Testing Telegram message!");
-      logger3.debug("Message sent successfully.");
+      logger4.debug("Message sent successfully.");
     } catch (error) {
       throw new Error(`Error sending Telegram message: ${error}`);
     }
@@ -1512,7 +2178,7 @@ var TelegramTestSuite = class {
         mockContext,
         messageContent
       );
-      logger3.success("Message with image attachment sent successfully.");
+      logger4.success("Message with image attachment sent successfully.");
     } catch (error) {
       throw new Error(`Error sending Telegram message with attachment: ${error}`);
     }
@@ -1573,7 +2239,7 @@ var TelegramTestSuite = class {
         throw new Error("Error processing Telegram image or description not found");
       }
       const { description } = result;
-      logger3.log(`Processing Telegram image successfully: ${description}`);
+      logger4.log(`Processing Telegram image successfully: ${description}`);
     } catch (error) {
       throw new Error(`Error processing Telegram image: ${error}`);
     }
@@ -1589,7 +2255,7 @@ var TelegramTestSuite = class {
       }
       return message.photo[message.photo.length - 1].file_id;
     } catch (error) {
-      logger3.error({ error }, `Error sending image: ${error}`);
+      logger4.error({ error }, `Error sending image: ${error}`);
       throw error;
     }
   }
@@ -1606,6 +2272,9 @@ var index_default = telegramPlugin;
 export {
   MessageManager,
   TelegramService,
-  index_default as default
+  index_default as default,
+  encodeUrlForTelegram,
+  generateAlternativeUrls,
+  isProblematicVideoUrl
 };
 //# sourceMappingURL=index.js.map
\ No newline at end of file
